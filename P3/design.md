## 设计草稿

将一个简单的单周期CPU拆分成`IFU`、`GRF`、`ALU`、`DM`、`Controller`五个模块，通过`MUX`等形成数据通路。

**支持的指令：**`add`、`addu`、`sub`、`subu`、`ori`、`lw`、`sw`、`beq`、`lui`、`nop`

**注意点：**

* 复位信号reset采用**异步复位**方式
* `add`、`sub`按无符号运算处理，等同于`addu`、`subu`
* `logisim`中`Memory`相关组件（如RAM、ROM）**按字寻址**，地址接入时应注意去除末2位。

**IFU（取指令单元）：**

* 内部包括 PC（程序计数器）、IM（指令存储器）及相关逻辑
* PC 用寄存器实现，具有复位功能，复位值为0
* 起始地址0x00000000
* IM 用 ROM 实现，容量为$1字\times 2^{5} = 32\textrm{bit}\times 32$
* IM 实际地址宽度为 5 位，需要使用恰当的方法将 PC 中储存的地址同 IM 联系起来
* 本P要求 PC 和 DM 的起始地址均为 0，而 MARS 不能将两者的地址区间设定重叠。因需要修改生成的指令机器码，或对电路进行一些处理来保证通过测试

**GRF（通用寄存器组，也称为寄存器文件、寄存器堆）：**

* 用具有写使能的寄存器实现，寄存器总数为 32 个，具有复位功能
* 0 号寄存器的值始终保持为 0。其他寄存器初始值（复位后）为 0

**ALU（算术逻辑单元）：**

* 通过`ALUControl`控制信号（`3位`）选择对应的计算功能，具体见下表

* 提供 32 位加、减、或运算及大小比较功能，其中大小比较功能独立输出、总是进行比较、不受控制信号影响

* 加、减法按无符号处理，不考虑溢出

  |    指令    | ALUControl信号 |              ALU功能              |
  | :--------: | :------------: | :-------------------------------: |
  | add / addu |      000       |            无符号加法             |
  | sub / subu |      001       |            无符号减法             |
  |    ori     |      010       | 寄存器值逻辑或立即数（高16位补0） |
  |    lui     |      011       |  立即数置输出高16位（低16位补0）  |

**DM（数据存储器）：**不采用模块电路

* 使用 RAM 实现，容量为$1字\times 2^{5} = 32\textrm{bit}\times 32$，具有复位功能，复位时清空所有内存为0
* 起始地址0x00000000
* RAM 读写端口分离

**Controller（控制器）：**

* 使用与、或门阵列构造控制信号，具体见下表

  | 指令 \ 控制信号 | RegDst | ALUSrc | MemToReg | RegWrite | MemWrite | Beq  | ALUCtr |
  | :-------------: | :----: | :----: | :------: | :------: | :------: | :--: | :----: |
  |   add / addu    |   1    |   0    |    0     |    1     |    0     |  0   |  000   |
  |   sub / subu    |   1    |   0    |    0     |    1     |    0     |  0   |  001   |
  |       lui       |   0    |   1    |    0     |    1     |    0     |  0   |  011   |
  |       ori       |   0    |   1    |    0     |    1     |    0     |  0   |  010   |
  |       sw        |   -    |   1    |    -     |    0     |    1     |  0   |  000   |
  |       lw        |   0    |   1    |    1     |    1     |    0     |  0   |  000   |
  |       beq       |   -    |   0    |    -     |    0     |    0     |  1   |   -    |
  |       nop       |   -    |   -    |    -     |    0     |    0     |  0   |   -    |

## 测试方案

先准备好自己写的`asm`测试汇编代码与待测试的`circ`电路文件，然后用`MARS`编译并导出十六进制机器码，对生成的`hexcode.txt`文件追加`v2.0 raw`头部，导入`logisim`的`IFU->ROM`中，开启时钟运行一段时间（可以是32个时钟周期），然后记录`RAM`与32个寄存器与`PC`的状态。再用`MARS`运行测试汇编代码，记录结束时的内存与各寄存器状态。比对一致则自测通过。以下是测试数据构造方案（源自教程，有删减）：

### 计算类指令功能测试

*寄存器数据*方面：

- 0及附近的数
- 32位数边界附近的数
- 32位数范围内的随机数

*无符号立即数*方面：

- 0及附近的数
- 16位无符号数边界附近的数
- 16位无符号数范围内的随机数

*有符号立即数*方面：(P3 不涉及)

- 0及附近的数
- 16位有符号数边界附近的数
- 16位有符号数范围内的随机数

特别的，可注意测试目标寄存器是`$0`的情况。

### 存取类指令功能测试

`offset`方面：

- offset 是正数
- offset 是零
- offset 是负数

`$base`寄存器方面：

- $base 寄存器中的值是正数
- $base 寄存器中的值是零
- $base 寄存器中的值是负数

对于`sw`指令，最好存入的Word中，每个Byte都不是0；对于`lw`指令，测试目标寄存器是`$0`的情况。

### 跳转类指令功能测试

对于*非比较*相关的部分：
- 跳转，且目标在此跳转指令之前
- 跳转，且目标是此跳转指令
- 跳转，且目标在此跳转指令之后
- 不跳转，且目标在此跳转指令之前
- 不跳转，且目标是此跳转指令
- 不跳转，且目标在此跳转指令之后

对于*比较*相关的部分，本质上依旧是构造寄存器数据，处理类似`计算类指令功能测试`

## 思考题

### Q：上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。

A：`GRF`、`DM`与`IFU`中的`PC`起到状态存储的功能，`IM`、`Controller`、`ALU`与`IFU`中的`NPC`电路逻辑起到状态转移的作用。

### Q：现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。

A：合理。从本次实验角度分析，单周期CPU的IM和DM需要分离，否则会产生结构冒险。从实际硬件角度分析，Register读写速度快于RAM快于ROM，同时绝大部分指令都需要用到GRF，DM读写操作频率其次，IO频率与实际硬件效率匹配；且IM中存放的是指令，一般不得在运行时被随意修改，有些情景下还需要保证掉电后其中存放的指令不丢失，因此用ROM最合适。

### Q：在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。

A：未实现。

### Q：事实上，实现 `nop` 空指令，我们并不需要将它加入控制信号真值表，为什么？

A：`Controller`模块保证`nop`时控制信号`RegWrite`、`MemWrite`均输出0，即并不会对GRF和DM产生实际影响；用状态机视角来看，CPU的“下游”状态机不会发生状态变化。

### Q：MARS 不能导出 PC 与 DM 起始地址均为 0 的机器码。实际上，可以避免手工修改的麻烦。请查阅相关资料进行了解，并阐释为了解决这个问题，你最终采用的方法。

A：根据课程对`MARS`的`CompactDataAtZero`的内存布局要求，代码段起始地址是0x00003000，这对导出代码的影响主要存在于跳转指令（因为其引用的是绝对地址），分支指令等则不受影响（因为其通过偏移引用相对地址）。因此在`NPC`计算逻辑后再加一段处理电路，当地址大于等于0x00003000时则在原地址基础上减去0x00003000。

### Q：阅读 Pre 的`MIPS 指令集及汇编语言`一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。

A：数据强度较弱。分析测试样例：对于`sw`、`lw`指令等，立即数未充分考虑边界数、负数等条件；测试指令不全面，未测试`nop`、`sub`指令；未用到所有寄存器，对寄存器的测试不够全面；分支跳转的偏移未考虑负数等。